local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.text")local d=require("am.log")local e=require("am.ui.base")local f=require("am.ui.bound")local g={}g.a=require("am.ui.anchor")g.c=require("am.ui.const")g.e=require("am.ui.event")g.h=require("am.ui.helpers")g.ScreenPos=e.ScreenPos;g.UIObject=e.UIObject;g.UILoop=require("am.ui.loop")local h=e.UIObject:extend("am.ui.Group")g.Group=h;function h:init(i)i=i or{}a.field(i,"id","string","nil")h.super.init(self,i)self.i={}return self end;function h:add(j)a.expect(1,j,"table")g.h.requireUIObject(j)if g.h.isUIScreen(j)then error("Cannot nest Screen UIs")end;self.i[j.id]=j end;function h:get(k,l)a.expect(1,k,"string")a.expect(2,l,"table","nil")if l~=nil then g.h.requireOutput(l)end;if self.i[k]~=nil then return self.i[k]:bind(l)end;for m,j in pairs(self.i)do if j:has(h)then local n=j:get(k,l)if n~=nil then return n end end end;return nil end;function h:remove(k)a.expect(1,k,"string")if self.i[k]~=nil then table.remove(self.i,k)return true end;for m,j in pairs(self.i)do if j:is(h)then local o=table.remove(j,k)if o then return true end end end;return false end;function h:reset()self.i={}end;function h:bind(l)return f.BoundGroup(l,self)end;function h:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;h.super.render(self,l)local p=l.getTextColor()local q=l.getBackgroundColor()local r,s=l.getCursorPos()for m,j in pairs(self.i)do j:render(l)end;l.setTextColor(p)l.setBackgroundColor(q)l.setCursorPos(r,s)end;function h:handle(l,t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")g.h.requireOutput(l)if t=="term_resize"or t=="monitor_resize"then self:render(l)return false end;for m,j in pairs(self.i)do if j:handle(l,{t,unpack(u)})then return true end end;return false end;local v=h:extend("am.ui.Screen")g.Screen=v;function v:init(l,i)i=i or{}a.expect(1,l,"table","nil")a.field(i,"id","string","nil")a.field(i,"textColor","number","nil")a.field(i,"backgroundColor","number","nil")if l==nil then l=term end;g.h.requireOutput(l)if i.textColor~=nil then a.range(i.textColor,1)end;if i.backgroundColor~=nil then a.range(i.backgroundColor,1)end;v.super.init(self,i)self.output=l;self.textColor=i.textColor;self.backgroundColor=i.backgroundColor;return self end;function v:get(k)a.expect(1,k,"string")return v.super.get(self,k,self.output)end;function v:render()if not self.visible then return end;local m,w=self.output.getSize()local x=g.h.getColor(self.textColor,self.output.getTextColor())local y=g.h.getColor(self.backgroundColor,self.output.getBackgroundColor())self.output.setTextColor(x)self.output.setBackgroundColor(y)self.output.clear()self.output.setCursorPos(1,1)self.output.setCursorBlink(false)v.super.render(self,self.output)self.output.setCursorPos(1,w)self.output.setTextColor(x)self.output.setBackgroundColor(y)end;function v:handle(t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,t,"string")local l;if g.c.l.Events.Always[t]then l=self.output else l=g.h.getEventOutput({t,unpack(u)})if not g.c.l.Events.UI[t]and not g.h.isSameScreen(self.output,l)then return false end end;if g.c.l.Events.UI[t]then local j=self:get(u[1].objId)if j~=nil then if not j:handle({t,unpack(u)})then return true end end;return false end;if t=="term_resize"or t=="monitor_resize"then self:render()return false end;for m,j in pairs(self.i)do if j:handle(l,{t,unpack(u)})then return true end end;return true end;function v:bind(l)return self end;local z=e.UIObject:extend("am.ui.Text")g.Text=z;function z:init(A,B,i)i=i or{}a.expect(1,A,"table")a.expect(2,B,"string")a.field(i,"id","string","nil")a.field(i,"textColor","number","nil")a.field(i,"backgroundColor","number","nil")if i.textColor~=nil then a.range(i.textColor,1)end;if i.backgroundColor~=nil then a.range(i.backgroundColor,1)end;z.super.init(self,i)self.label=B;self.anchor=A;self.textColor=i.textColor;self.backgroundColor=i.backgroundColor;self:validate()return self end;function z:validate(l)z.super.validate(self,l)a.field(self,"label","string")a.field(self,"anchor","table")a.field(self,"textColor","number","nil")a.field(self,"backgroundColor","number","nil")if not g.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end end;function z:handle(l,t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")g.h.requireOutput(l)if t==g.c.e.Events.text_update and u[1].objId==self.id then local C=u[1].oldLabel;local D=u[1].newLabel;if#D<#C then self.label=string.rep(" ",#C)self:render(l)end;self.label=u[1].newLabel;self:render(l)return true end;return false end;function z:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;z.super.render(self,l)local p=l.getTextColor()local E=l.getBackgroundColor()local r,s=l.getCursorPos()local F,G=c.getTextColor(self.label)local H=self.anchor:getPos(l,#F,1)local x=g.h.getColor(self.textColor,G,l.getTextColor())local y=g.h.getColor(self.backgroundColor,l.getBackgroundColor())l.setTextColor(x)l.setBackgroundColor(y)l.setCursorPos(H.x,H.y)l.write(F)l.setTextColor(p)l.setBackgroundColor(E)l.setCursorPos(r,s)end;function z:update(l,B)a.expect(1,l,"table")a.expect(2,B,"string")g.h.requireOutput(l)if self.label~=B then local t=g.e.TextUpdateEvent(l,self.id,self.label,B)self.label=B;os.queueEvent(t.name,t)end end;function z:bind(l)return f.BoundText(l,self)end;local I=h:extend("am.ui.Frame")g.Frame=I;function I:init(A,i)i=i or{}a.expect(1,A,"table")a.field(i,"id","string","nil")a.field(i,"width","number","nil")a.field(i,"height","number","nil")a.field(i,"fillHorizontal","boolean","nil")a.field(i,"fillVertical","boolean","nil")a.field(i,"padLeft","number","nil")a.field(i,"padRight","number","nil")a.field(i,"padTop","number","nil")a.field(i,"padBottom","number","nil")a.field(i,"backgroundColor","number","nil")a.field(i,"borderColor","number","nil")a.field(i,"fillColor","number","nil")a.field(i,"textColor","number","nil")a.field(i,"border","number","nil")a.field(i,"bubble","boolean","nil")I.super.init(self,i)if i.fillHorizontal==nil then i.fillHorizontal=false end;if i.fillVertical==nil then i.fillVertical=false end;if i.padding==nil then i.padding=1 end;if i.borderColor==nil then i.borderColor=colors.gray end;if i.border==nil then i.border=1 end;if i.padLeft==nil then i.padLeft=0 end;if i.padRight==nil then i.padRight=i.padLeft end;if i.padTop==nil then i.padTop=math.max(0,i.padLeft-1)end;if i.padBottom==nil then i.padBottom=i.padTop end;if i.bubble==nil then i.bubble=true end;self.anchor=A;self.width=i.width;self.height=i.height;self.fillHorizontal=i.fillHorizontal;self.fillVertical=i.fillVertical;self.padLeft=i.padLeft;self.padRight=i.padRight;self.padTop=i.padTop;self.padBottom=i.padBottom;self.backgroundColor=i.backgroundColor;self.borderColor=i.borderColor;self.fillColor=i.fillColor;self.textColor=i.textColor;self.border=i.border;self.bubble=i.bubble;self:validate()return self end;function I:get(k,l)a.expect(1,k,"string")a.expect(2,l,"table","nil")if l~=nil then g.h.requireOutput(l)l=self:makeScreen(l)end;return I.super.get(self,k,l)end;function I:validate(l)a.field(self,"border","number")a.range(self.border,0,3)a.field(self,"anchor","table")if not g.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end;a.field(self,"width","number","nil")if self.width~=nil then a.range(self.width,1)end;a.field(self,"height","number","nil")if self.height~=nil then if self.border>0 then a.range(self.height,3)else a.range(self.height,1)end end;if self.backgroundColor~=nil then a.field(self,"backgroundColor","number")a.range(self.backgroundColor,1)end;if self.fillColor~=nil then a.field(self,"fillColor","number")a.range(self.fillColor,1)end;if self.borderColor~=nil then a.field(self,"borderColor","number")a.range(self.borderColor,1)end;if self.textColor~=nil then a.field(self,"textColor","number")a.range(self.textColor,1)end end;function I:getBackgroundColor(l)a.expect(1,l,"table","nil")if l~=nil then g.h.requireOutput(l)return g.h.getColor(self.backgroundColor,l.getBackgroundColor())end;return self.backgroundColor end;function I:getFillColor(l)return self.fillColor end;function I:getBorderColor(l)a.expect(1,l,"table","nil")if l~=nil then g.h.requireOutput(l)g.h.getColor(self.borderColor,l.getBackgroundColor())end;return self.borderColor end;function I:getTextColor(l)a.expect(1,l,"table","nil")if l~=nil then g.h.requireOutput(l)return g.h.getColor(self.textColor,l.getTextColor())end;return self.textColor end;function I:getBaseWidth()local J=self.width;if J~=nil then return J end;J=1+self.padLeft+self.padRight;if self.border>0 then J=J+2 end;return J end;function I:getWidth(l,K)a.expect(2,K,"number","nil")if K==nil then K=self.anchor:getXPos(l,self:getBaseWidth())end;local J=self:getBaseWidth()if self.fillHorizontal and not(self.anchor:is(g.a.Right)or self.anchor:is(g.a.TopRight)or self.anchor:is(g.a.BottomRight))then local L,m=l.getSize()J=L-K+1 end;return J end;function I:getBaseHeight()local w=self.height;if w~=nil then return w end;w=1+self.padTop+self.padBottom;if self.border>0 then w=w+2 end;return w end;function I:getHeight(l,M)a.expect(2,M,"number","nil")local w=self:getBaseHeight()if self.fillVertical and not(self.anchor:is(g.a.Bottom)and self.anchor:is(g.a.BottomLeft)and self.anchor:is(g.a.BottomRight))then local m,N=l.getSize()w=N-M+1 end;return w end;function I:makeScreen(l,H,J,w,O)a.expect(1,l,"table")a.expect(2,H,"table","nil")a.expect(3,J,"number","nil")a.expect(4,w,"number","nil")a.expect(5,O,"boolean","nil")g.h.requireOutput(l)if H==nil then H=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())else H=b.copy(H)end;if O==nil then O=true end;if not g.h.isPos(H)then error("pos must be a ScreenPos")end;if J==nil then J=self:getWidth(l,H.x)end;if w==nil then w=self:getHeight(l,H.y)end;if self.border>0 then J=J-2;w=w-2;H.x=H.x+1;H.y=H.y+1 end;local P=e.FrameScreen(l,self.id,b.copy(H),J,w,self:getTextColor(l),self:getFillColor(l))if O then P:addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)end;return P:ccCompat()end;function I:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;self:validate(l)local p=l.getTextColor()local q=l.getBackgroundColor()local r,s=l.getCursorPos()local H=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())local J=self:getWidth(l,H.x)local w=self:getHeight(l,H.y)local y=self:getBackgroundColor(l)local Q=self:getBorderColor(l)local x=self:getTextColor(l)if self.border>0 and(self:getBackgroundColor()~=nil or self:getBorderColor()~=nil)then if self.border==1 then g.h.renderBorder1(l,H,J,w,y,Q)elseif self.border==2 then g.h.renderBorder2(l,H,J,w,y,Q)else g.h.renderBorder3(l,H,J,w,Q)end end;l.setTextColor(x)l.setBackgroundColor(g.h.getColor(self:getFillColor(l),q))local P=self:makeScreen(l,H,J,w,false)if self:getFillColor()~=nil then P.clear()end;g.h.getFrameScreen(P):addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)I.super.render(self,P)l.setTextColor(p)l.setBackgroundColor(q)l.setCursorPos(r,s)end;function I:within(l,R,S)if not self.visible then return false end;a.expect(1,l,"table")g.h.requireOutput(l)a.expect(2,R,"number")a.expect(3,S,"number")a.range(R,1)a.range(S,1)self:validate(l)local T=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())if g.h.isFrameScreen(l)then l=g.h.getFrameScreen(l)T=e.ScreenPos(l:toAbsolutePos(T.x,T.y))end;local J=self:getWidth(l,T.x)local w=self:getHeight(l,T.y)local U=e.ScreenPos(T.x+J-1,T.y+w-1)return R>=T.x and R<=U.x and S>=T.y and S<=U.y end;function I:handle(l,t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")g.h.requireOutput(l)local P=self:makeScreen(l)for m,j in pairs(self.i)do if j:handle(P,{t,unpack(u)})then return not self.bubble end end;if t=="mouse_click"or t=="mouse_up"or t=="monitor_touch"then local H=e.ScreenPos(u[2],u[3])local V=nil;if self:within(l,H.x,H.y)then local W=g.h.getFrameScreen(P)local R,S=W:toRealtivePos(H.x,H.y)local X=W:getClickArea(R,S,self.padLeft,self.padRight,self.padTop,self.padBottom)if t=="mouse_click"then V=g.e.FrameClickEvent(l,self.id,R,S,X,u[1])elseif t=="mouse_up"then V=g.e.FrameDeactivateEvent(l,self.id,R,S,X,u[1])else V=g.e.FrameTouchEvent(l,self.id,R,S,X)end;if V~=nil then os.queueEvent(V.name,V)end;return not self.bubble end end;return false end;function I:bind(l)return f.BoundFrame(l,self)end;local Y=I:extend("am.ui.Button")g.Button=Y;function Y:init(A,B,i)i=i or{}a.expect(1,A,"table")a.expect(2,B,"string")a.field(i,"labelAnchor","table","nil")a.field(i,"disabled","boolean","nil")a.field(i,"activateOnTouch","boolean","nil")a.field(i,"activateOnLeftClick","boolean","nil")a.field(i,"activateOnRightClick","boolean","nil")a.field(i,"activateOnMiddleClick","boolean","nil")if i.labelAnchor==nil then i.labelAnchor=g.a.Middle()end;if i.padLeft==nil then i.padLeft=1 end;if i.disabled==nil then i.disabled=false end;if i.activateOnTouch==nil then i.activateOnTouch=true end;if i.activateOnLeftClick==nil then i.activateOnLeftClick=true end;if i.activateOnRightClick==nil then i.activateOnRightClick=true end;if i.activateOnMiddleClick==nil then i.activateOnMiddleClick=true end;Y.super.init(self,A,i)self.label=z(i.labelAnchor,B,{id=string.format("%s.label",self.id)})self.disabled=i.disabled;self.activated=false;self.activateOnTouch=i.activateOnTouch;self.activateOnLeftClick=i.activateOnLeftClick;self.activateOnRightClick=i.activateOnRightClick;self.activateOnMiddleClick=i.activateOnMiddleClick;self.activateHandlers={}self.touchTimer=nil;self:add(self.label)self:validate()return self end;function Y:updateLabel(l,B)l=self:makeScreen(l)self.label:update(l,B)end;function Y:getBaseWidth()local J=Y.super.getBaseWidth(self)if self.width~=nil then return J end;return J+#self.label.label-1 end;function Y:getFillColor(l)a.expect(1,l,"table","nil")if l~=nil and self.activated then g.h.requireOutput(l)g.h.getColor(self.borderColor,l.getBackgroundColor())end;if self.activated then return self.borderColor end;return self.fillColor end;function Y:getBorderColor(l)a.expect(1,l,"table","nil")if l~=nil and not self.activated then g.h.requireOutput(l)g.h.getColor(self.borderColor,l.getBackgroundColor())end;if self.activated then return self.fillColor end;return self.borderColor end;function Y:activate(l,Z)if self.disabled or self.activated then return end;a.expect(2,Z,"boolean","nil")self.activated=true;local t=g.e.ButtonActivateEvent(l,self.id,Z)os.queueEvent(t.name,t)end;function Y:deactivate(l)if not self.activated then return end;self.activated=false;local t=g.e.ButtonDeactivateEvent(l,self.id)os.queueEvent(t.name,t)end;function Y:addActivateHandler(_)a.expect(1,_,"function")local k=tostring(_)self.activateHandlers[k]=_;return function()self.activateHandlers[k]=nil end end;function Y:onActivate(l,t)if self.disabled then return end;self.activated=true;for m,_ in pairs(self.activateHandlers)do _(self,l,t)end;self:render(l)if t.touch then self.touchTimer=os.startTimer(0.5)end end;function Y:onDeactivate(l,t)self.activated=false;self:render(l)end;function Y:onTouch(l,t)if self.disabled or self.activated or not self.activateOnTouch then return end;self:activate(l,true)end;function Y:onClick(l,t)if self.disabled or self.activated then return end;if t.clickType==g.c.Click.Left and self.activateOnLeftClick then self:activate(l)elseif t.clickType==g.c.Click.Right and self.activateOnRightClick then self:activate(l)elseif t.clickType==g.c.Click.Middle and self.activateOnMiddleClick then self:activate(l)end end;function Y:onUp(l,t)if self.disabled or not self.activated then return end;self:deactivate(l)end;function Y:get(k,l)a.expect(1,k,"string")a.expect(2,l,"table","nil")if k==self.label.id then return self:bind(l)end;if l~=nil then g.h.requireOutput(l)l=self:makeScreen(l)end;return I.super.get(self,k,l)end;function Y:handle(l,t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")g.h.requireOutput(l)if g.c.l.Events.UI[t]then local a0=u[1]if a0.objId==self.id then if t==g.c.e.Events.frame_touch then self:onTouch(l,a0)elseif t==g.c.e.Events.frame_click then self:onClick(l,a0)elseif t==g.c.e.Events.frame_up then self:onUp(l,a0)elseif t==g.c.e.Events.button_activate then self:onActivate(l,a0)elseif t==g.c.e.Events.button_deactivate then self:onDeactivate(l,a0)end elseif t==g.c.e.Events.text_update then if a0.objId==self.label.id then local C=a0.oldLabel;local D=a0.newLabel;if#D<#C then local q=self.backgroundColor;local a1=self.borderColor;local a2=self.fillColor;self.backgroundColor=l.getBackgroundColor()self.borderColor=l.getBackgroundColor()self.fillColor=l.getBackgroundColor()self.label.label=string.rep(" ",#C)self:render(l)self.backgroundColor=q;self.borderColor=a1;self.fillColor=a2 end;self.label.label=D;self:render(l)return true end end;return not self.bubble elseif t=="timer"then if u[1]==self.touchTimer then self.touchTimer=nil;self:deactivate(l)end end;return Y.super.handle(self,l,{t,unpack(u)})end;function Y:bind(l)return f.BoundButton(l,self)end;local a3=I:extend("am.ui.ProgressBar")g.ProgressBar=a3;function a3:init(A,i)i=i or{}a.expect(1,A,"table")a.field(i,"label","string","nil")a.field(i,"labelAnchor","table","nil")a.field(i,"current","number","nil")a.field(i,"total","number","nil")a.field(i,"displayTotal","number","nil")a.field(i,"progressColor","number","nil")a.field(i,"progressTextColor","number","nil")a.field(i,"progressVertical","boolean","nil")a.field(i,"showProgress","boolean","nil")a.field(i,"showPercent","boolean","nil")a.field(i,"bubble","boolean","nil")if i.label==nil then i.label=""end;if i.labelAnchor==nil then i.labelAnchor=g.a.TopLeft()end;if i.total==nil then i.total=100 end;if i.current==nil then i.current=0 end;if i.progressColor==nil then i.progressColor=colors.green end;if i.progressTextColor==nil then i.progressTextColor=i.textColor end;if i.showProgress==nil then i.showProgress=true end;if i.showPercent==nil then i.showPercent=true end;if i.progressVertical==nil then i.progressVertical=false end;if i.fillHorizontal==nil then i.fillHorizontal=true end;if i.fillVertical==nil then if i.progressVertical then i.fillVertical=true end end;if i.bubble==nil then i.bubble=true end;Y.super.init(self,A,i)self.baseLabel=i.label;self.current=i.current;self.displayTotal=i.displayTotal;self.total=i.total;self.progressColor=i.progressColor;self.progressTextColor=i.progressTextColor;self.progressVertical=i.progressVertical;self.showProgress=i.showProgress;self.showPercent=i.showPercent;self.label=z(i.labelAnchor,self:getLabelText(),{id=string.format("%s.label",self.id)})self.fillFrame=I(g.a.BottomLeft(),{id=string.format("%s.fill",self.id),fillVertical=true,border=0})self.fillLabel=z(g.a.Anchor(1,1),self:getLabelText(),{id=string.format("%s.fillLabel",self.id)})self:add(self.label)self:validate()return self end;function a3:validate(l)a3.super.validate(self,l)if self.fillFrame==nil then return end;a.field(self,"baseLabel","string")a.field(self,"current","number")a.range(self.current,0)a.field(self,"total","number")a.range(self.total,math.floor(self.current))a.field(self,"displayTotal","number","nil")a.field(self,"progressColor","number")a.range(self.progressColor,1)a.field(self,"showPercent","boolean")a.field(self,"showProgress","boolean")self.padLeft=0;self.padRight=0;self.padTop=0;self.padBottom=0 end;function a3:bind(l)return f.BoundProgressBar(l,self)end;function a3:get(k,l)a.expect(1,k,"string")a.expect(2,l,"table","nil")if k==self.label.id or k==self.fillFrame.id or k==self.fillLabel.id then return self:bind(l)end;if l~=nil then g.h.requireOutput(l)l=self:makeScreen(l)end;return I.super.get(self,k,l)end;function a3:getLabelText()local B=self.baseLabel;local a4=math.min(self.current,self.total)local a5=a4/self.total;if self.showPercent then B=B..string.format(" %d%%",a5*100)end;if self.showProgress then local a6=self.current;local a7=self.total;if self.displayTotal~=nil then a6=math.floor(a5*self.displayTotal)a7=self.displayTotal end;B=B..string.format(" [%d/%d]",a6,a7)end;return B end;function a3:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;local a8=self:makeScreen(l)local p=l.getTextColor()local q=l.getBackgroundColor()local r,s=l.getCursorPos()local B=self:getLabelText()self.label.label=B;self.label.textColor=self:getTextColor(l)a3.super.render(self,l)local a4=math.min(self.current,self.total)local a5=a4/self.total;local a9,aa=a8.getSize()local ab=self.label.anchor:getPos(a8,#B,1)local ac;if self.progressVertical then ac=math.floor(aa*a5)else ac=math.floor(a9*a5)end;if ac>0 then self.fillLabel.label=B;self.fillLabel.textColor=self.progressTextColor;local ad=false;if self.progressVertical then ab.y=ab.y-(aa-ac)if ab.y>0 then ad=true end;self.fillFrame.width=a9;self.fillFrame.height=ac;self.fillFrame.fillVertical=false;self.fillFrame.fillHorizontal=true else if ab.x<=ac then ad=true end;self.fillFrame.width=ac;self.fillFrame.height=aa;self.fillFrame.fillVertical=true;self.fillFrame.fillHorizontal=false end;if ad then self.fillLabel.anchor.x=ab.x;self.fillLabel.anchor.y=ab.y;self.fillFrame:add(self.fillLabel)else self.fillFrame:reset()end;self.fillFrame.fillColor=self.progressColor;self.fillFrame:render(a8)end;l.setTextColor(p)l.setBackgroundColor(q)l.setCursorPos(r,s)end;function a3:updateLabel(l,B,ae,af)a.expect(1,l,"table")a.expect(2,B,"string","nil")a.expect(3,ae,"boolean","nil")a.expect(4,af,"boolean","nil")g.h.requireOutput(l)local ag=B~=nil and self.baseLabel~=B;local ah=ae~=nil and self.showProgress~=ae;local ai=af~=nil and self.showPercent~=af;if not(ag or ah or ai)then return end;local t=g.e.ProgressBarLabelUpdateEvent(l,self.id)if ag then t.oldLabel=self.baseLabel;t.newLabel=B;self.baseLabel=B end;if ah then t.oldShowProgress=self.showProgress;t.newShowProgress=ae;self.showProgress=ae end;if ai then t.oldShowPercent=self.showPercent;t.newShowPercent=af;self.showPercent=af end;os.queueEvent(t.name,t)end;function a3:update(l,a4)a.expect(1,l,"table")a.expect(2,a4,"number")g.h.requireOutput(l)a4=math.min(self.total,math.max(0,a4))if self.current==a4 then return end;local t=g.e.ProgressBarUpdateEvent(l,self.id,self.current,a4)self.current=a4;os.queueEvent(t.name,t)end;function a3:handle(l,t,...)local t,u=b.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")g.h.requireOutput(l)if t==g.c.e.Events.progress_label_update and u[1].objId==self.id then if u[1].newLabel~=nil then self.baseLabel=u[1].newLabel elseif u[1].newShowProgress~=nil then self.showProgress=u[1].newShowProgress elseif u[1].newShowPercent~=nil then self.showPercent=u[1].newShowPercent end;self:render(l)return not self.bubble elseif t==g.c.e.Events.progress_update and u[1].objId==self.id then self.current=math.min(self.total,math.max(0,u[1].newCurrent))self:render(l)return not self.bubble end;a3.super.handle(self,l,{t,unpack(u)})return false end;return g
