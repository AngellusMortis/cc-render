local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.text")local d=require("am.ui.base")local e=require("am.ui.bound")local f={}f.a=require("am.ui.anchor")f.c=require("am.ui.const")f.e=require("am.ui.event")f.h=require("am.ui.helpers")f.ScreenPos=d.ScreenPos;f.UIObject=d.UIObject;f.UILoop=require("am.ui.loop")local g=d.UIObject:extend("am.ui.Group")f.Group=g;function g:init(h)h=h or{}a.field(h,"id","string","nil")g.super.init(self,h)self.i={}return self end;function g:add(i)a.expect(1,i,"table")f.h.requireUIObject(i)if f.h.isUIScreen(i)then error("Cannot nest Screen UIs")end;self.i[i.id]=i end;function g:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if k~=nil then f.h.requireOutput(k)end;if self.i[j]~=nil then return self.i[j]:bind(k)end;for l,i in pairs(self.i)do if i:has(g)then local m=i:get(j,k)if m~=nil then return m end end end;return nil end;function g:remove(j)a.expect(1,j,"string")if self.i[j]~=nil then table.remove(self.i,j)return true end;for l,i in pairs(self.i)do if i:is(g)then local n=table.remove(i,j)if n then return true end end end;return false end;function g:reset()self.i={}end;function g:bind(k)return e.BoundGroup(k,self)end;function g:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;g.super.render(self,k)local o=k.getTextColor()local p=k.getBackgroundColor()local q,r=k.getCursorPos()for l,i in pairs(self.i)do i:render(k)end;k.setTextColor(o)k.setBackgroundColor(p)k.setCursorPos(q,r)end;function g:handle(k,s,...)local s,t=b.cleanEventArgs(s,...)a.expect(1,k,"table")a.expect(2,s,"string")f.h.requireOutput(k)if s=="term_resize"or s=="monitor_resize"then self:render(k)return false end;for l,i in pairs(self.i)do if i:handle(k,{s,unpack(t)})then return true end end;return false end;local u=g:extend("am.ui.Screen")f.Screen=u;function u:init(k,h)h=h or{}a.expect(1,k,"table","nil")a.field(h,"id","string","nil")a.field(h,"textColor","number","nil")a.field(h,"backgroundColor","number","nil")if k==nil then k=term end;f.h.requireOutput(k)if h.textColor~=nil then a.range(h.textColor,1)end;if h.backgroundColor~=nil then a.range(h.backgroundColor,1)end;u.super.init(self,h)self.output=k;self.textColor=h.textColor;self.backgroundColor=h.backgroundColor;return self end;function u:get(j)a.expect(1,j,"string")return u.super.get(self,j,self.output)end;function u:render()if not self.visible then return end;local l,v=self.output.getSize()local w=f.h.getColor(self.textColor,self.output.getTextColor())local x=f.h.getColor(self.backgroundColor,self.output.getBackgroundColor())self.output.setTextColor(w)self.output.setBackgroundColor(x)self.output.clear()self.output.setCursorPos(1,1)self.output.setCursorBlink(false)u.super.render(self,self.output)self.output.setCursorPos(1,v)self.output.setTextColor(w)self.output.setBackgroundColor(x)end;function u:handle(s,...)local s,t=b.cleanEventArgs(s,...)a.expect(1,s,"string")local k=f.h.getEventOutput({s,unpack(t)})if not f.c.l.Events.UI[s]and not f.h.isSameScreen(self.output,k)then return false end;if f.c.l.Events.UI[s]then local i=self:get(t[1].objId)if i~=nil then if not i:handle({s,unpack(t)})then return true end end;return false end;if s=="term_resize"or s=="monitor_resize"then self:render()return false end;for l,i in pairs(self.i)do if i:handle(k,{s,unpack(t)})then return true end end;return true end;function u:bind(k)return self end;local y=d.UIObject:extend("am.ui.Text")f.Text=y;function y:init(z,A,h)h=h or{}a.expect(1,z,"table")a.expect(2,A,"string")a.field(h,"id","string","nil")a.field(h,"textColor","number","nil")a.field(h,"backgroundColor","number","nil")if h.textColor~=nil then a.range(h.textColor,1)end;if h.backgroundColor~=nil then a.range(h.backgroundColor,1)end;y.super.init(self,h)self.label=A;self.anchor=z;self.textColor=h.textColor;self.backgroundColor=h.backgroundColor;self:validate()return self end;function y:validate(k)y.super.validate(self,k)a.field(self,"label","string")a.field(self,"anchor","table")a.field(self,"textColor","number","nil")a.field(self,"backgroundColor","number","nil")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end end;function y:handle(k,s,...)local s,t=b.cleanEventArgs(s,...)a.expect(1,k,"table")a.expect(2,s,"string")f.h.requireOutput(k)if s==f.c.e.Events.text_update and t[1].objId==self.id then local B=t[1].oldLabel;local C=t[1].newLabel;if#C<#B then self.label=string.rep(" ",#B)self:render(k)end;self.label=t[1].newLabel;self:render(k)return true end;return false end;function y:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;y.super.render(self,k)local o=k.getTextColor()local D=k.getBackgroundColor()local q,r=k.getCursorPos()local E,F=c.getTextColor(self.label)local G=self.anchor:getPos(k,#E,1)local w=f.h.getColor(self.textColor,F,k.getTextColor())local x=f.h.getColor(self.backgroundColor,k.getBackgroundColor())k.setTextColor(w)k.setBackgroundColor(x)k.setCursorPos(G.x,G.y)k.write(E)k.setTextColor(o)k.setBackgroundColor(D)k.setCursorPos(q,r)end;function y:update(k,A)a.expect(1,k,"table")a.expect(2,A,"string")f.h.requireOutput(k)if self.label~=A then local s=f.e.TextUpdateEvent(k,self.id,self.label,A)self.label=A;os.queueEvent(s.name,s)end end;function y:bind(k)return e.BoundText(k,self)end;local H=g:extend("am.ui.Frame")f.Frame=H;function H:init(z,h)h=h or{}a.expect(1,z,"table")a.field(h,"id","string","nil")a.field(h,"width","number","nil")a.field(h,"height","number","nil")a.field(h,"fillHorizontal","boolean","nil")a.field(h,"fillVertical","boolean","nil")a.field(h,"padLeft","number","nil")a.field(h,"padRight","number","nil")a.field(h,"padTop","number","nil")a.field(h,"padBottom","number","nil")a.field(h,"backgroundColor","number","nil")a.field(h,"borderColor","number","nil")a.field(h,"fillColor","number","nil")a.field(h,"textColor","number","nil")a.field(h,"border","number","nil")a.field(h,"bubble","boolean","nil")H.super.init(self,h)if h.fillHorizontal==nil then h.fillHorizontal=false end;if h.fillVertical==nil then h.fillVertical=false end;if h.padding==nil then h.padding=1 end;if h.borderColor==nil then h.borderColor=colors.gray end;if h.border==nil then h.border=1 end;if h.padLeft==nil then h.padLeft=0 end;if h.padRight==nil then h.padRight=h.padLeft end;if h.padTop==nil then h.padTop=math.max(0,h.padLeft-1)end;if h.padBottom==nil then h.padBottom=h.padTop end;if h.bubble==nil then h.bubble=true end;self.anchor=z;self.width=h.width;self.height=h.height;self.fillHorizontal=h.fillHorizontal;self.fillVertical=h.fillVertical;self.padLeft=h.padLeft;self.padRight=h.padRight;self.padTop=h.padTop;self.padBottom=h.padBottom;self.backgroundColor=h.backgroundColor;self.borderColor=h.borderColor;self.fillColor=h.fillColor;self.textColor=h.textColor;self.border=h.border;self.bubble=h.bubble;self:validate()return self end;function H:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if k~=nil then f.h.requireOutput(k)k=self:makeScreen(k)end;return H.super.get(self,j,k)end;function H:validate(k)a.field(self,"border","number")a.range(self.border,0,3)a.field(self,"anchor","table")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end;a.field(self,"width","number","nil")if self.width~=nil then a.range(self.width,1)end;a.field(self,"height","number","nil")if self.height~=nil then if self.border>0 then a.range(self.height,3)else a.range(self.height,1)end end;if self.backgroundColor~=nil then a.field(self,"backgroundColor","number")a.range(self.backgroundColor,1)end;if self.fillColor~=nil then a.field(self,"fillColor","number")a.range(self.fillColor,1)end;if self.borderColor~=nil then a.field(self,"borderColor","number")a.range(self.borderColor,1)end;if self.textColor~=nil then a.field(self,"textColor","number")a.range(self.textColor,1)end end;function H:getBackgroundColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)return f.h.getColor(self.backgroundColor,k.getBackgroundColor())end;return self.backgroundColor end;function H:getFillColor(k)return self.fillColor end;function H:getBorderColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;return self.borderColor end;function H:getTextColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)return f.h.getColor(self.textColor,k.getTextColor())end;return self.textColor end;function H:getBaseWidth()local I=self.width;if I~=nil then return I end;I=1+self.padLeft+self.padRight;if self.border>0 then I=I+2 end;return I end;function H:getWidth(k,J)a.expect(2,J,"number","nil")if J==nil then J=self.anchor:getXPos(k,self:getBaseWidth())end;local I=self:getBaseWidth()if self.fillHorizontal and not(self.anchor:is(f.a.Right)or self.anchor:is(f.a.TopRight)or self.anchor:is(f.a.BottomRight))then local K,l=k.getSize()I=K-J+1 end;return I end;function H:getBaseHeight()local v=self.height;if v~=nil then return v end;v=1+self.padTop+self.padBottom;if self.border>0 then v=v+2 end;return v end;function H:getHeight(k,L)a.expect(2,L,"number","nil")local v=self:getBaseHeight()if self.fillVertical and not(self.anchor:is(f.a.Bottom)and self.anchor:is(f.a.BottomLeft)and self.anchor:is(f.a.BottomRight))then local l,M=k.getSize()v=M-L+1 end;return v end;function H:makeScreen(k,G,I,v,N)a.expect(1,k,"table")a.expect(2,G,"table","nil")a.expect(3,I,"number","nil")a.expect(4,v,"number","nil")a.expect(5,N,"boolean","nil")f.h.requireOutput(k)if G==nil then G=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())else G=b.copy(G)end;if N==nil then N=true end;if not f.h.isPos(G)then error("pos must be a ScreenPos")end;if I==nil then I=self:getWidth(k,G.x)end;if v==nil then v=self:getHeight(k,G.y)end;if self.border>0 then I=I-2;v=v-2;G.x=G.x+1;G.y=G.y+1 end;local O=d.FrameScreen(k,self.id,b.copy(G),I,v,self:getTextColor(k),self:getFillColor(k))if N then O:addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)end;return O:ccCompat()end;function H:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;self:validate(k)local o=k.getTextColor()local p=k.getBackgroundColor()local q,r=k.getCursorPos()local G=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())local I=self:getWidth(k,G.x)local v=self:getHeight(k,G.y)local x=self:getBackgroundColor(k)local P=self:getBorderColor(k)local w=self:getTextColor(k)if self.border>0 and(self:getBackgroundColor()~=nil or self:getBorderColor()~=nil)then if self.border==1 then f.h.renderBorder1(k,G,I,v,x,P)elseif self.border==2 then f.h.renderBorder2(k,G,I,v,x,P)else f.h.renderBorder3(k,G,I,v,P)end end;k.setTextColor(w)k.setBackgroundColor(f.h.getColor(self:getFillColor(k),p))local O=self:makeScreen(k,G,I,v,false)if self:getFillColor()~=nil then O.clear()end;f.h.getFrameScreen(O):addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)H.super.render(self,O)k.setTextColor(o)k.setBackgroundColor(p)k.setCursorPos(q,r)end;function H:within(k,Q,R)if not self.visible then return false end;a.expect(1,k,"table")f.h.requireOutput(k)a.expect(2,Q,"number")a.expect(3,R,"number")a.range(Q,1)a.range(R,1)self:validate(k)local S=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())if f.h.isFrameScreen(k)then k=f.h.getFrameScreen(k)S=d.ScreenPos(k:toAbsolutePos(S.x,S.y))end;local I=self:getWidth(k,S.x)local v=self:getHeight(k,S.y)local T=d.ScreenPos(S.x+I-1,S.y+v-1)return Q>=S.x and Q<=T.x and R>=S.y and R<=T.y end;function H:handle(k,s,...)local s,t=b.cleanEventArgs(s,...)a.expect(1,k,"table")a.expect(2,s,"string")f.h.requireOutput(k)local O=self:makeScreen(k)for l,i in pairs(self.i)do if i:handle(O,{s,unpack(t)})then return self.bubble end end;if s=="mouse_click"or s=="mouse_up"or s=="monitor_touch"then local G=d.ScreenPos(t[2],t[3])local U=nil;if self:within(k,G.x,G.y)then local Q,R=f.h.getFrameScreen(O):toRealtivePos(G.x,G.y)if s=="mouse_click"then U=f.e.FrameClickEvent(k,self.id,Q,R,t[1])elseif s=="mouse_up"then U=f.e.FrameDeactivateEvent(k,self.id,Q,R,t[1])else U=f.e.FrameTouchEvent(k,self.id,Q,R)end;if U~=nil then os.queueEvent(U.name,U)end;return self.bubble end end;return false end;function H:bind(k)return e.BoundFrame(k,self)end;local V=H:extend("am.ui.Button")f.Button=V;function V:init(z,A,h)h=h or{}a.expect(1,z,"table")a.expect(2,A,"string")a.field(h,"labelAnchor","table","nil")a.field(h,"disabled","boolean","nil")a.field(h,"activateOnTouch","boolean","nil")a.field(h,"activateOnLeftClick","boolean","nil")a.field(h,"activateOnRightClick","boolean","nil")a.field(h,"activateOnMiddleClick","boolean","nil")if h.labelAnchor==nil then h.labelAnchor=f.a.Middle()end;if h.padLeft==nil then h.padLeft=1 end;if h.disabled==nil then h.disabled=false end;if h.activateOnTouch==nil then h.activateOnTouch=true end;if h.activateOnLeftClick==nil then h.activateOnLeftClick=true end;if h.activateOnRightClick==nil then h.activateOnRightClick=true end;if h.activateOnMiddleClick==nil then h.activateOnMiddleClick=true end;V.super.init(self,z,h)self.label=y(h.labelAnchor,A,{id=string.format("%s.label",self.id)})self.disabled=h.disabled;self.activated=false;self.activateOnTouch=h.activateOnTouch;self.activateOnLeftClick=h.activateOnLeftClick;self.activateOnRightClick=h.activateOnRightClick;self.activateOnMiddleClick=h.activateOnMiddleClick;self.activateHandlers={}self.touchTimer=nil;self:add(self.label)self:validate()return self end;function V:updateLabel(k,A)k=self:makeScreen(k)self.label:update(k,A)end;function V:getBaseWidth()local I=V.super.getBaseWidth(self)if self.width~=nil then return I end;return I+#self.label.label-1 end;function V:getFillColor(k)a.expect(1,k,"table","nil")if k~=nil and self.activated then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;if self.activated then return self.borderColor end;return self.fillColor end;function V:getBorderColor(k)a.expect(1,k,"table","nil")if k~=nil and not self.activated then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;if self.activated then return self.fillColor end;return self.borderColor end;function V:activate(k,W)if self.disabled or self.activated then return end;a.expect(2,W,"boolean","nil")self.activated=true;local s=f.e.ButtonActivateEvent(k,self.id,W)os.queueEvent(s.name,s)end;function V:deactivate(k)if not self.activated then return end;self.activated=false;local s=f.e.ButtonDeactivateEvent(k,self.id)os.queueEvent(s.name,s)end;function V:addActivateHandler(X)a.expect(1,X,"function")local j=tostring(X)self.activateHandlers[j]=X;return function()self.activateHandlers[j]=nil end end;function V:onActivate(k,s)if self.disabled then return end;self.activated=true;for l,X in pairs(self.activateHandlers)do X(self,k,s)end;self:render(k)if s.touch then self.touchTimer=os.startTimer(0.5)end end;function V:onDeactivate(k,s)self.activated=false;self:render(k)end;function V:onTouch(k,s)if self.disabled or self.activated or not self.activateOnTouch then return end;self:activate(k,true)end;function V:onClick(k,s)if self.disabled or self.activated then return end;if s.clickType==f.c.Click.Left and self.activateOnLeftClick then self:activate(k)elseif s.clickType==f.c.Click.Right and self.activateOnRightClick then self:activate(k)elseif s.clickType==f.c.Click.Middle and self.activateOnMiddleClick then self:activate(k)end end;function V:onUp(k,s)if self.disabled or not self.activated then return end;self:deactivate(k)end;function V:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if j==self.label.id then return self:bind(k)end;if k~=nil then f.h.requireOutput(k)k=self:makeScreen(k)end;return H.super.get(self,j,k)end;function V:handle(k,s,...)local s,t=b.cleanEventArgs(s,...)a.expect(1,k,"table")a.expect(2,s,"string")f.h.requireOutput(k)if f.c.l.Events.UI[s]then local Y=t[1]if Y.objId==self.id then if s==f.c.e.Events.frame_touch then self:onTouch(k,Y)elseif s==f.c.e.Events.frame_click then self:onClick(k,Y)elseif s==f.c.e.Events.frame_up then self:onUp(k,Y)elseif s==f.c.e.Events.button_activate then self:onActivate(k,Y)elseif s==f.c.e.Events.button_deactivate then self:onDeactivate(k,Y)end elseif s==f.c.e.Events.text_update then if Y.objId==self.label.id then local B=Y.oldLabel;local C=Y.newLabel;if#C<#B then local p=self.backgroundColor;local Z=self.borderColor;local _=self.fillColor;self.backgroundColor=k.getBackgroundColor()self.borderColor=k.getBackgroundColor()self.fillColor=k.getBackgroundColor()self.label.label=string.rep(" ",#B)self:render(k)self.backgroundColor=p;self.borderColor=Z;self.fillColor=_ end;self.label.label=C;self:render(k)return true end end;return self.bubble elseif s=="timer"then if t[1]==self.touchTimer then self.touchTimer=nil;self:deactivate(k)end end;return V.super.handle(self,k,{s,unpack(t)})end;function V:bind(k)return e.BoundButton(k,self)end;local a0=H:extend("am.ui.ProgressBar")f.ProgressBar=a0;function a0:init(z,h)h=h or{}a.expect(1,z,"table")a.field(h,"label","string","nil")a.field(h,"labelAnchor","table","nil")a.field(h,"current","number","nil")a.field(h,"total","number","nil")a.field(h,"displayTotal","number","nil")a.field(h,"progressColor","number","nil")a.field(h,"progressTextColor","number","nil")a.field(h,"progressVertical","boolean","nil")a.field(h,"showProgress","boolean","nil")a.field(h,"showPercent","boolean","nil")if h.label==nil then h.label=""end;if h.labelAnchor==nil then h.labelAnchor=f.a.TopLeft()end;if h.total==nil then h.total=100 end;if h.current==nil then h.current=0 end;if h.progressColor==nil then h.progressColor=colors.green end;if h.progressTextColor==nil then h.progressTextColor=h.textColor end;if h.showProgress==nil then h.showProgress=true end;if h.showPercent==nil then h.showPercent=true end;if h.progressVertical==nil then h.progressVertical=false end;if h.fillHorizontal==nil then h.fillHorizontal=true end;if h.fillVertical==nil then if h.progressVertical then h.fillVertical=true end end;V.super.init(self,z,h)self.baseLabel=h.label;self.label=y(h.labelAnchor,"",{id=string.format("%s.label",self.id)})self.fillFrame=H(f.a.BottomLeft(),{id=string.format("%s.fill",self.id),fillVertical=true,border=0})self.fillLabel=y(f.a.Anchor(1,1),"",{id=string.format("%s.fillLabel",self.id)})self.current=h.current;self.displayCurrent=nil;self.displayTotal=h.displayTotal;self.total=h.total;self.progressColor=h.progressColor;self.progressTextColor=h.progressTextColor;self.progressVertical=h.progressVertical;self.showProgress=h.showProgress;self.showPercent=h.showPercent;self:add(self.label)self:validate()return self end;function a0:validate(k)a0.super.validate(self,k)if self.fillFrame==nil then return end;a.field(self,"baseLabel","string")a.field(self,"current","number")a.range(self.current,0)a.field(self,"total","number")a.range(self.total,math.floor(self.current))a.field(self,"displayCurrent","number","nil")a.field(self,"displayTotal","number","nil")if self.displayCurrent~=nil and self.displayTotal~=nil then a.range(self.displayTotal,math.floor(self.displayCurrent))end;a.field(self,"progressColor","number")a.range(self.progressColor,1)a.field(self,"showPercent","boolean")a.field(self,"showProgress","boolean")self.padLeft=0;self.padRight=0;self.padTop=0;self.padBottom=0 end;function a0:bind(k)return e.BoundProgressBar(k,self)end;function a0:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if j==self.label.id or j==self.fillFrame.id or j==self.fillLabel.id then return self:bind(k)end;if k~=nil then f.h.requireOutput(k)k=self:makeScreen(k)end;return H.super.get(self,j,k)end;function a0:getLabelText()local A=self.baseLabel;local a1=math.min(self.current,self.total)local a2=a1/self.total;if self.showPercent then A=A..string.format(" %d%%",a2*100)end;if self.showProgress then local a3=self.displayCurrent;local a4=self.displayTotal;if a3==nil or a4==nil then a3=self.current;a4=self.total end;A=A..string.format(" [%d/%d]",a3,a4)end;return A end;function a0:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;local o=k.getTextColor()local p=k.getBackgroundColor()local q,r=k.getCursorPos()local a5=self:makeScreen(k)local a6,a7=a5.getSize()local a1=math.min(self.current,self.total)local a2=a1/self.total;local A=self:getLabelText()local a8=self.label.anchor:getPos(a5,#A,1)self.label.label=A;a0.super.render(self,k)local a9;if self.progressVertical then a9=math.floor(a7*a2)else a9=math.floor(a6*a2)end;if a9>0 then self.fillLabel.label=A;self.fillLabel.textColor=self.progressTextColor;local aa=false;if self.progressVertical then a8.y=a8.y-(a7-a9)if a8.y>0 then aa=true end;self.fillFrame.width=a6;self.fillFrame.height=a9;self.fillFrame.fillVertical=false;self.fillFrame.fillHorizontal=true else if a8.x<=a9 then aa=true end;self.fillFrame.width=a9;self.fillFrame.height=a7;self.fillFrame.fillVertical=true;self.fillFrame.fillHorizontal=false end;if aa then self.fillLabel.anchor.x=a8.x;self.fillLabel.anchor.y=a8.y;self.fillFrame:add(self.fillLabel)else self.fillFrame:reset()end;self.fillFrame.fillColor=self.progressColor;self.fillFrame:render(a5)end;k.setTextColor(o)k.setBackgroundColor(p)k.setCursorPos(q,r)end;return f
