local a=require("cc.expect")local b=require(settings.get("ghu.base").."core/apis/ghu")local c=require("am.core")local d=require("am.text")local e=require("am.ui.base")local f={}f.a=require("am.ui.anchor")f.c=require("am.ui.const")f.e=require("am.ui.event")f.h=require("am.ui.helpers")f.ScreenPos=e.ScreenPos;f.UIObject=e.UIObject;f.UILoop=require("am.ui.loop")local g=e.UIObject:extend("am.ui.Group")f.Group=g;function g:init(h)h=h or{}a.field(h,"id","string","nil")g.super.init(self,h)self.i={}return self end;function g:add(i)a.expect(1,i,"table")if not f.h.isUIObject(i)then error("Not a valid UI obj")elseif f.h.isUIScreen(i)then error("Cannot nest Screen UIs")end;self.i[i.id]=i end;function g:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if k~=nil then f.h.requireOutput(k)end;if self.i[j]~=nil then return self.i[j],k end;for l,i in pairs(self.i)do if i:has(g)then local m,n=i:get(j,k)if m~=nil then return m,n or k end end end;return nil,nil end;function g:remove(j)a.expect(1,j,"string")if self.i[j]~=nil then table.remove(self.i,j)return true end;for l,i in pairs(self.i)do if i:is(g)then local o=table.remove(i,j)if o then return true end end end;return false end;function g:reset()self.i={}end;function g:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;g.super.render(self,k)local p=k.getTextColor()local q=k.getBackgroundColor()local r,s=k.getCursorPos()for l,i in pairs(self.i)do i:render(k)end;k.setTextColor(p)k.setBackgroundColor(q)k.setCursorPos(r,s)end;function g:handle(k,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,k,"table")a.expect(2,t,"string")f.h.requireOutput(k)if t=="term_resize"or t=="monitor_resize"then self:render(k)return false end;for l,i in pairs(self.i)do if i:handle(k,{t,unpack(u)})then return true end end;return false end;local v=g:extend("am.ui.Screen")f.Screen=v;function v:init(k,h)h=h or{}a.expect(1,k,"table","nil")a.field(h,"id","string","nil")a.field(h,"textColor","number","nil")a.field(h,"backgroundColor","number","nil")if k==nil then k=term end;f.h.requireOutput(k)if h.textColor~=nil then a.range(h.textColor,1)end;if h.backgroundColor~=nil then a.range(h.backgroundColor,1)end;v.super.init(self,h)self.output=k;self.textColor=h.textColor;self.backgroundColor=h.backgroundColor;return self end;function v:get(j)a.expect(1,j,"string")return v.super.get(self,j,self.output)end;function v:render()if not self.visible then return end;local l,w=self.output.getSize()local x=f.h.getColor(self.textColor,self.output.getTextColor())local y=f.h.getColor(self.backgroundColor,self.output.getBackgroundColor())self.output.setTextColor(x)self.output.setBackgroundColor(y)self.output.clear()self.output.setCursorPos(1,1)self.output.setCursorBlink(false)v.super.render(self,self.output)self.output.setCursorPos(1,w)self.output.setTextColor(x)self.output.setBackgroundColor(y)end;function v:handle(k,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,k,"table")a.expect(2,t,"string")f.h.requireOutput(k)if not f.c.l.Events.UI[t]and not f.h.isSameScreen(self.output,k)then return false end;if f.c.l.Events.UI[t]then local i,z=self:get(u[1].objId)if i~=nil and z~=nil then if not i:handle(z,{t,unpack(u)})then return true end end;return false end;if t=="term_resize"or t=="monitor_resize"then self:render()return false end;for l,i in pairs(self.i)do if i:handle(k,{t,unpack(u)})then return true end end;return true end;local A=e.UIObject:extend("ui.Text")f.Text=A;function A:init(B,C,h)h=h or{}a.expect(1,B,"table")a.expect(2,C,"string")a.field(h,"id","string","nil")a.field(h,"textColor","number","nil")a.field(h,"backgroundColor","number","nil")if h.textColor~=nil then a.range(h.textColor,1)end;if h.backgroundColor~=nil then a.range(h.backgroundColor,1)end;A.super.init(self,h)self.label=C;self.anchor=B;self.textColor=h.textColor;self.backgroundColor=h.backgroundColor;self:validate()return self end;function A:validate(k)A.super.validate(self,k)a.field(self,"label","string")a.field(self,"anchor","table")a.field(self,"textColor","number","nil")a.field(self,"backgroundColor","number","nil")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end end;function A:handle(k,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,k,"table")a.expect(2,t,"string")f.h.requireOutput(k)if t==f.c.e.Events.text_update and u[1].objId==self.id then local D=u[1].oldLabel;local E=u[1].newLabel;if#E<#D then self.label=string.rep(" ",#D)self:render(k)end;self.label=u[1].newLabel;self:render(k)return true end;return false end;function A:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;A.super.render(self,k)local p=k.getTextColor()local F=k.getBackgroundColor()local r,s=k.getCursorPos()local G,H=d.getTextColor(self.label)local I=self.anchor:getPos(k,#G,1)local x=f.h.getColor(self.textColor,H,k.getTextColor())local y=f.h.getColor(self.backgroundColor,k.getBackgroundColor())k.setTextColor(x)k.setBackgroundColor(y)k.setCursorPos(I.x,I.y)k.write(G)k.setTextColor(p)k.setBackgroundColor(F)k.setCursorPos(r,s)end;function A:update(k,C)a.expect(1,k,"table")a.expect(2,C,"string")f.h.requireOutput(k)if self.label~=C then local t=f.e.TextUpdateEvent(k,self.id,self.label,C)self.label=C;os.queueEvent(t.name,t)end end;local J=g:extend("am.ui.Frame")f.Frame=J;function J:init(B,h)h=h or{}a.expect(1,B,"table")a.field(h,"id","string","nil")a.field(h,"width","number","nil")a.field(h,"height","number","nil")a.field(h,"fillHorizontal","boolean","nil")a.field(h,"fillVertical","boolean","nil")a.field(h,"padLeft","number","nil")a.field(h,"padRight","number","nil")a.field(h,"padTop","number","nil")a.field(h,"padBottom","number","nil")a.field(h,"backgroundColor","number","nil")a.field(h,"borderColor","number","nil")a.field(h,"fillColor","number","nil")a.field(h,"textColor","number","nil")a.field(h,"border","number","nil")a.field(h,"bubble","boolean","nil")J.super.init(self,h)if h.fillHorizontal==nil then h.fillHorizontal=false end;if h.fillVertical==nil then h.fillVertical=false end;if h.padding==nil then h.padding=1 end;if h.borderColor==nil then h.borderColor=colors.gray end;if h.border==nil then h.border=1 end;if h.padLeft==nil then h.padLeft=0 end;if h.padRight==nil then h.padRight=h.padLeft end;if h.padTop==nil then h.padTop=math.max(0,h.padLeft-1)end;if h.padBottom==nil then h.padBottom=h.padTop end;if h.bubble==nil then h.bubble=true end;self.anchor=B;self.width=h.width;self.height=h.height;self.fillHorizontal=h.fillHorizontal;self.fillVertical=h.fillVertical;self.padLeft=h.padLeft;self.padRight=h.padRight;self.padTop=h.padTop;self.padBottom=h.padBottom;self.backgroundColor=h.backgroundColor;self.borderColor=h.borderColor;self.fillColor=h.fillColor;self.textColor=h.textColor;self.border=h.border;self.bubble=h.bubble;self:validate()return self end;function J:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if k~=nil then f.h.requireOutput(k)k=self:makeScreen(k)end;return J.super.get(self,j,k)end;function J:validate(k)a.field(self,"border","number")a.range(self.border,0,3)a.field(self,"anchor","table")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end;a.field(self,"width","number","nil")if self.width~=nil then a.range(self.width,1)end;a.field(self,"height","number","nil")if self.height~=nil then if self.border>0 then a.range(self.height,3)else a.range(self.height,1)end end;if self.backgroundColor~=nil then a.field(self,"backgroundColor","number")a.range(self.backgroundColor,1)end;if self.fillColor~=nil then a.field(self,"fillColor","number")a.range(self.fillColor,1)end;if self.borderColor~=nil then a.field(self,"borderColor","number")a.range(self.borderColor,1)end;if self.textColor~=nil then a.field(self,"textColor","number")a.range(self.textColor,1)end end;function J:getBackgroundColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)return f.h.getColor(self.backgroundColor,k.getBackgroundColor())end;return self.backgroundColor end;function J:getFillColor(k)return self.fillColor end;function J:getBorderColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;return self.borderColor end;function J:getTextColor(k)a.expect(1,k,"table","nil")if k~=nil then f.h.requireOutput(k)return f.h.getColor(self.textColor,k.getTextColor())end;return self.textColor end;function J:getBaseWidth()local K=self.width;if K~=nil then return K end;K=1+self.padLeft+self.padRight;if self.border>0 then K=K+2 end;return K end;function J:getWidth(k,L)a.expect(2,L,"number","nil")if L==nil then L=self.anchor:getXPos(k,self:getBaseWidth())end;local K=self:getBaseWidth()if self.fillHorizontal and not(self.anchor:is(f.a.Right)or self.anchor:is(f.a.TopRight)or self.anchor:is(f.a.BottomRight))then local M,l=k.getSize()K=M-L end;return K end;function J:getBaseHeight()local w=self.height;if w~=nil then return w end;w=1+self.padTop+self.padBottom;if self.border>0 then w=w+2 end;return w end;function J:getHeight(k,N)a.expect(2,N,"number","nil")local w=self:getBaseHeight()if self.fillVertical and not(self.anchor:is(f.a.Bottom)and self.anchor:is(f.a.BottomLeft)and self.anchor:is(f.a.BottomRight))then local l,O=k.getSize()w=O-N+1 end;return w end;function J:makeScreen(k,I,K,w,P)a.expect(1,k,"table")a.expect(2,I,"table","nil")a.expect(3,K,"number","nil")a.expect(4,w,"number","nil")a.expect(5,P,"boolean","nil")f.h.requireOutput(k)if I==nil then I=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())else I=c.copy(I)end;if P==nil then P=true end;if not f.h.isPos(I)then error("pos must be a ScreenPos")end;if K==nil then K=self:getWidth(k,I.x)end;if w==nil then w=self:getHeight(k,I.y)end;if self.border>0 then K=K-2;w=w-2;I.x=I.x+1;I.y=I.y+1 end;local Q=e.FrameScreen(k,self.id,c.copy(I),K,w,self:getTextColor(k),self:getFillColor(k))if P then Q:addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)end;local R=fs.open("debug.log","a")R.writeLine(string.format("%s %s %s %s %s",self.id,Q.basePos.x,Q.basePos.y,Q.width,Q.height))R.close()return Q:ccCompat()end;function J:render(k)if not self.visible then return end;a.expect(1,k,"table","nil")if k==nil then k=term end;self:validate(k)local p=k.getTextColor()local q=k.getBackgroundColor()local r,s=k.getCursorPos()local I=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())local K=self:getWidth(k,I.x)local w=self:getHeight(k,I.y)local y=self:getBackgroundColor(k)local S=self:getBorderColor(k)local x=self:getTextColor(k)if self.border>0 and(self:getBackgroundColor()~=nil or self:getBorderColor()~=nil)then if self.border==1 then f.h.renderBorder1(k,I,K,w,y,S)elseif self.border==2 then f.h.renderBorder2(k,I,K,w,y,S)else f.h.renderBorder3(k,I,K,w,S)end end;k.setTextColor(x)k.setBackgroundColor(f.h.getColor(self:getFillColor(k),q))local Q=self:makeScreen(k,I,K,w,false)if self:getFillColor()~=nil then Q.clear()end;f.h.getFrameScreen(Q):addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)J.super.render(self,Q)k.setTextColor(p)k.setBackgroundColor(q)k.setCursorPos(r,s)end;function J:within(k,T,U)if not self.visible then return false end;a.expect(1,k,"table")f.h.requireOutput(k)a.expect(2,T,"number")a.expect(3,U,"number")a.range(T,1)a.range(U,1)self:validate(k)local V=self.anchor:getPos(k,self:getBaseWidth(),self:getBaseHeight())if f.h.isFrameScreen(k)then k=f.h.getFrameScreen(k)V=e.ScreenPos(k:toAbsolutePos(V.x,V.y))end;local K=self:getWidth(k,V.x)local w=self:getHeight(k,V.y)local W=e.ScreenPos(V.x+K-1,V.y+w-1)return T>=V.x and T<=W.x and U>=V.y and U<=W.y end;function J:handle(k,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,k,"table")a.expect(2,t,"string")f.h.requireOutput(k)local Q=self:makeScreen(k)for l,i in pairs(self.i)do if i:handle(Q,{t,unpack(u)})then return self.bubble end end;if t=="mouse_click"or t=="mouse_up"or t=="monitor_touch"then local I=e.ScreenPos(u[2],u[3])local X=nil;if self:within(k,I.x,I.y)then local T,U=f.h.getFrameScreen(Q):toRealtivePos(I.x,I.y)if t=="mouse_click"then X=f.e.FrameClickEvent(k,self.id,T,U,u[1])elseif t=="mouse_up"then X=f.e.FrameDeactivateEvent(k,self.id,T,U,u[1])else X=f.e.FrameTouchEvent(k,self.id,T,U)end;if X~=nil then os.queueEvent(X.name,X)end;return self.bubble end end;return false end;local Y=J:extend("am.ui.Button")f.Button=Y;function Y:init(B,C,h)h=h or{}a.expect(1,B,"table")a.expect(2,C,"string")a.field(h,"labelAnchor","table","nil")a.field(h,"disabled","boolean","nil")a.field(h,"activateOnTouch","boolean","nil")a.field(h,"activateOnLeftClick","boolean","nil")a.field(h,"activateOnRightClick","boolean","nil")a.field(h,"activateOnMiddleClick","boolean","nil")if h.labelAnchor==nil then h.labelAnchor=f.a.Middle()end;if h.padLeft==nil then h.padLeft=1 end;if h.disabled==nil then h.disabled=false end;if h.activateOnTouch==nil then h.activateOnTouch=true end;if h.activateOnLeftClick==nil then h.activateOnLeftClick=true end;if h.activateOnRightClick==nil then h.activateOnRightClick=true end;if h.activateOnMiddleClick==nil then h.activateOnMiddleClick=true end;Y.super.init(self,B,h)self.label=A(h.labelAnchor,C,{id=string.format("%s.label",self.id)})self.disabled=h.disabled;self.activated=false;self.activateOnTouch=h.activateOnTouch;self.activateOnLeftClick=h.activateOnLeftClick;self.activateOnRightClick=h.activateOnRightClick;self.activateOnMiddleClick=h.activateOnMiddleClick;self.activateHandlers={}self.touchTimer=nil;self:add(self.label)self:validate()return self end;function Y:updateLabel(k,C)k=self:makeScreen(k)self.label:update(k,C)end;function Y:getBaseWidth()local K=Y.super.getBaseWidth(self)if self.width~=nil then return K end;return K+#self.label.label-1 end;function Y:activate(k,Z)if self.disabled or self.activated then return end;a.expect(2,Z,"boolean","nil")self.activated=true;local t=f.e.ButtonActivateEvent(k,self.id,Z)os.queueEvent(t.name,t)end;function Y:deactivate(k)if not self.activated then return end;self.activated=false;local t=f.e.ButtonDeactivateEvent(k,self.id)os.queueEvent(t.name,t)end;function Y:addActivateHandler(_)a.expect(1,_,"function")local j=tostring(_)self.activateHandlers[j]=_;return function()self.activateHandlers[j]=nil end end;function Y:onActivate(k,t)if self.disabled then return end;self.activated=true;for l,_ in pairs(self.activateHandlers)do _(self,k,t)end;self:render(k)if t.touch then self.touchTimer=os.startTimer(0.5)end end;function Y:onDeactivate(k,t)self.activated=false;self:render(k)end;function Y:onTouch(k,t)if self.disabled or self.activated or not self.activateOnTouch then return end;self:activate(k,true)end;function Y:onClick(k,t)if self.disabled or self.activated then return end;if t.clickType==f.c.Click.Left and self.activateOnLeftClick then self:activate(k)elseif t.clickType==f.c.Click.Right and self.activateOnRightClick then self:activate(k)elseif t.clickType==f.c.Click.Middle and self.activateOnMiddleClick then self:activate(k)end end;function Y:onUp(k,t)if self.disabled or not self.activated then return end;self:deactivate(k)end;function Y:get(j,k)a.expect(1,j,"string")a.expect(2,k,"table","nil")if j==self.label.id then return self,k end;if k~=nil then f.h.requireOutput(k)k=self:makeScreen(k)end;return J.super.get(self,j,k)end;function Y:handle(k,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,k,"table")a.expect(2,t,"string")f.h.requireOutput(k)if f.c.l.Events.UI[t]then local a0=u[1]if a0.objId==self.id then if t==f.c.e.Events.frame_touch then self:onTouch(k,a0)elseif t==f.c.e.Events.frame_click then self:onClick(k,a0)elseif t==f.c.e.Events.frame_up then self:onUp(k,a0)elseif t==f.c.e.Events.button_activate then self:onActivate(k,a0)elseif t==f.c.e.Events.button_deactivate then self:onDeactivate(k,a0)end elseif t==f.c.e.Events.text_update then if a0.objId==self.label.id then local D=a0.oldLabel;local E=a0.newLabel;if#E<#D then local q=self.backgroundColor;local a1=self.borderColor;local a2=self.fillColor;self.backgroundColor=k.getBackgroundColor()self.borderColor=k.getBackgroundColor()self.fillColor=k.getBackgroundColor()self.label.label=string.rep(" ",#D)self:render(k)self.backgroundColor=q;self.borderColor=a1;self.fillColor=a2 end;self.label.label=E;self:render(k)return true end end;return self.bubble elseif t=="timer"then if u[1]==self.touchTimer then self.touchTimer=nil;self:deactivate(k)end end;return Y.super.handle(self,k,{t,unpack(u)})end;function Y:getFillColor(k)a.expect(1,k,"table","nil")if k~=nil and self.activated then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;if self.activated then return self.borderColor end;return self.fillColor end;function Y:getBorderColor(k)a.expect(1,k,"table","nil")if k~=nil and not self.activated then f.h.requireOutput(k)f.h.getColor(self.borderColor,k.getBackgroundColor())end;if self.activated then return self.fillColor end;return self.borderColor end;return f
