local a=require("cc.expect")local b=require(settings.get("ghu.base").."core/apis/ghu")local c=require("am.core")local d=require("am.text")local e=require("am.ui.base")local f={}f.a=require("am.ui.anchor")f.c=require("am.ui.const")f.e=require("am.ui.event")f.h=require("am.ui.helpers")f.ScreenPos=e.ScreenPos;f.UIObject=e.UIObject;f.UILoop=require("am.ui.loop")local g=e.UIBoundObject:extend("am.ui.BoundGroup")e.BoundGroup=g;function g:add(h)self.obj:add(h)end;function g:get(i)return self.obj:get(i,self.output)end;function g:remove(i)return self.obj:remove(i)end;function g:reset()self.obj:reset()end;local j=e.UIObject:extend("am.ui.Group")f.Group=j;function j:init(k)k=k or{}a.field(k,"id","string","nil")j.super.init(self,k)self.i={}return self end;function j:add(h)a.expect(1,h,"table")f.h.requireUIObject(h)if f.h.isUIScreen(h)then error("Cannot nest Screen UIs")end;self.i[h.id]=h end;function j:get(i,l)a.expect(1,i,"string")a.expect(2,l,"table","nil")if l~=nil then f.h.requireOutput(l)end;if self.i[i]~=nil then return self.i[i]:bind(l)end;for m,h in pairs(self.i)do if h:has(j)then local n=h:get(i,l)if n~=nil then return n end end end;return nil end;function j:remove(i)a.expect(1,i,"string")if self.i[i]~=nil then table.remove(self.i,i)return true end;for m,h in pairs(self.i)do if h:is(j)then local o=table.remove(h,i)if o then return true end end end;return false end;function j:reset()self.i={}end;function j:bind(l)return g(l,self)end;function j:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;j.super.render(self,l)local p=l.getTextColor()local q=l.getBackgroundColor()local r,s=l.getCursorPos()for m,h in pairs(self.i)do h:render(l)end;l.setTextColor(p)l.setBackgroundColor(q)l.setCursorPos(r,s)end;function j:handle(l,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")f.h.requireOutput(l)if t=="term_resize"or t=="monitor_resize"then self:render(l)return false end;for m,h in pairs(self.i)do if h:handle(l,{t,unpack(u)})then return true end end;return false end;local v=j:extend("am.ui.Screen")f.Screen=v;function v:init(l,k)k=k or{}a.expect(1,l,"table","nil")a.field(k,"id","string","nil")a.field(k,"textColor","number","nil")a.field(k,"backgroundColor","number","nil")if l==nil then l=term end;f.h.requireOutput(l)if k.textColor~=nil then a.range(k.textColor,1)end;if k.backgroundColor~=nil then a.range(k.backgroundColor,1)end;v.super.init(self,k)self.output=l;self.textColor=k.textColor;self.backgroundColor=k.backgroundColor;return self end;function v:get(i)a.expect(1,i,"string")return v.super.get(self,i,self.output)end;function v:render()if not self.visible then return end;local m,w=self.output.getSize()local x=f.h.getColor(self.textColor,self.output.getTextColor())local y=f.h.getColor(self.backgroundColor,self.output.getBackgroundColor())self.output.setTextColor(x)self.output.setBackgroundColor(y)self.output.clear()self.output.setCursorPos(1,1)self.output.setCursorBlink(false)v.super.render(self,self.output)self.output.setCursorPos(1,w)self.output.setTextColor(x)self.output.setBackgroundColor(y)end;function v:handle(t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,t,"string")local l=f.h.getEventOutput({t,unpack(u)})if not f.c.l.Events.UI[t]and not f.h.isSameScreen(self.output,l)then return false end;if f.c.l.Events.UI[t]then local h=self:get(u[1].objId)if h~=nil then if not h:handle({t,unpack(u)})then return true end end;return false end;if t=="term_resize"or t=="monitor_resize"then self:render()return false end;for m,h in pairs(self.i)do if h:handle(l,{t,unpack(u)})then return true end end;return true end;function v:bind(l)return self end;local z=e.UIBoundObject:extend("am.ui.BoundText")e.BoundText=z;function z:update(A)self.obj:update(self.output,A)end;local B=e.UIObject:extend("am.ui.Text")f.Text=B;function B:init(C,A,k)k=k or{}a.expect(1,C,"table")a.expect(2,A,"string")a.field(k,"id","string","nil")a.field(k,"textColor","number","nil")a.field(k,"backgroundColor","number","nil")if k.textColor~=nil then a.range(k.textColor,1)end;if k.backgroundColor~=nil then a.range(k.backgroundColor,1)end;B.super.init(self,k)self.label=A;self.anchor=C;self.textColor=k.textColor;self.backgroundColor=k.backgroundColor;self:validate()return self end;function B:validate(l)B.super.validate(self,l)a.field(self,"label","string")a.field(self,"anchor","table")a.field(self,"textColor","number","nil")a.field(self,"backgroundColor","number","nil")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end end;function B:handle(l,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")f.h.requireOutput(l)if t==f.c.e.Events.text_update and u[1].objId==self.id then local D=u[1].oldLabel;local E=u[1].newLabel;if#E<#D then self.label=string.rep(" ",#D)self:render(l)end;self.label=u[1].newLabel;self:render(l)return true end;return false end;function B:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;B.super.render(self,l)local p=l.getTextColor()local F=l.getBackgroundColor()local r,s=l.getCursorPos()local G,H=d.getTextColor(self.label)local I=self.anchor:getPos(l,#G,1)local x=f.h.getColor(self.textColor,H,l.getTextColor())local y=f.h.getColor(self.backgroundColor,l.getBackgroundColor())l.setTextColor(x)l.setBackgroundColor(y)l.setCursorPos(I.x,I.y)l.write(G)l.setTextColor(p)l.setBackgroundColor(F)l.setCursorPos(r,s)end;function B:update(l,A)a.expect(1,l,"table")a.expect(2,A,"string")f.h.requireOutput(l)if self.label~=A then local t=f.e.TextUpdateEvent(l,self.id,self.label,A)self.label=A;os.queueEvent(t.name,t)end end;function B:bind(l)return z(l,self)end;local J=g:extend("am.ui.BoundFrame")e.BoundFrame=J;function J:getBackgroundColor()return self.obj:getBackgroundColor(self.output)end;function J:getFillColor()return self.obj:getFillColor(self.output)end;function J:getBorderColor()return self.obj:getBorderColor(self.output)end;function J:getTextColor()return self.obj:getTextColor(self.output)end;function J:getBaseWidth()return self.obj:getBaseWidth()end;function J:getWidth(K)return self.obj:getWidth(self.output,K)end;function J:getBaseHeight()return self.obj:getBaseHeight()end;function J:getHeight(L)return self.obj:getHeight(self.output,L)end;function J:makeScreen(I,M,w,N)return self.obj:makeScreen(self.output,I,M,w,N)end;function J:within(O,P)return self.obj:within(self.output,O,P)end;local Q=j:extend("am.ui.Frame")f.Frame=Q;function Q:init(C,k)k=k or{}a.expect(1,C,"table")a.field(k,"id","string","nil")a.field(k,"width","number","nil")a.field(k,"height","number","nil")a.field(k,"fillHorizontal","boolean","nil")a.field(k,"fillVertical","boolean","nil")a.field(k,"padLeft","number","nil")a.field(k,"padRight","number","nil")a.field(k,"padTop","number","nil")a.field(k,"padBottom","number","nil")a.field(k,"backgroundColor","number","nil")a.field(k,"borderColor","number","nil")a.field(k,"fillColor","number","nil")a.field(k,"textColor","number","nil")a.field(k,"border","number","nil")a.field(k,"bubble","boolean","nil")Q.super.init(self,k)if k.fillHorizontal==nil then k.fillHorizontal=false end;if k.fillVertical==nil then k.fillVertical=false end;if k.padding==nil then k.padding=1 end;if k.borderColor==nil then k.borderColor=colors.gray end;if k.border==nil then k.border=1 end;if k.padLeft==nil then k.padLeft=0 end;if k.padRight==nil then k.padRight=k.padLeft end;if k.padTop==nil then k.padTop=math.max(0,k.padLeft-1)end;if k.padBottom==nil then k.padBottom=k.padTop end;if k.bubble==nil then k.bubble=true end;self.anchor=C;self.width=k.width;self.height=k.height;self.fillHorizontal=k.fillHorizontal;self.fillVertical=k.fillVertical;self.padLeft=k.padLeft;self.padRight=k.padRight;self.padTop=k.padTop;self.padBottom=k.padBottom;self.backgroundColor=k.backgroundColor;self.borderColor=k.borderColor;self.fillColor=k.fillColor;self.textColor=k.textColor;self.border=k.border;self.bubble=k.bubble;self:validate()return self end;function Q:get(i,l)a.expect(1,i,"string")a.expect(2,l,"table","nil")if l~=nil then f.h.requireOutput(l)l=self:makeScreen(l)end;return Q.super.get(self,i,l)end;function Q:validate(l)a.field(self,"border","number")a.range(self.border,0,3)a.field(self,"anchor","table")if not f.h.isAnchor(self.anchor)then error("anchor much be of type Anchor")end;a.field(self,"width","number","nil")if self.width~=nil then a.range(self.width,1)end;a.field(self,"height","number","nil")if self.height~=nil then if self.border>0 then a.range(self.height,3)else a.range(self.height,1)end end;if self.backgroundColor~=nil then a.field(self,"backgroundColor","number")a.range(self.backgroundColor,1)end;if self.fillColor~=nil then a.field(self,"fillColor","number")a.range(self.fillColor,1)end;if self.borderColor~=nil then a.field(self,"borderColor","number")a.range(self.borderColor,1)end;if self.textColor~=nil then a.field(self,"textColor","number")a.range(self.textColor,1)end end;function Q:getBackgroundColor(l)a.expect(1,l,"table","nil")if l~=nil then f.h.requireOutput(l)return f.h.getColor(self.backgroundColor,l.getBackgroundColor())end;return self.backgroundColor end;function Q:getFillColor(l)return self.fillColor end;function Q:getBorderColor(l)a.expect(1,l,"table","nil")if l~=nil then f.h.requireOutput(l)f.h.getColor(self.borderColor,l.getBackgroundColor())end;return self.borderColor end;function Q:getTextColor(l)a.expect(1,l,"table","nil")if l~=nil then f.h.requireOutput(l)return f.h.getColor(self.textColor,l.getTextColor())end;return self.textColor end;function Q:getBaseWidth()local M=self.width;if M~=nil then return M end;M=1+self.padLeft+self.padRight;if self.border>0 then M=M+2 end;return M end;function Q:getWidth(l,K)a.expect(2,K,"number","nil")if K==nil then K=self.anchor:getXPos(l,self:getBaseWidth())end;local M=self:getBaseWidth()if self.fillHorizontal and not(self.anchor:is(f.a.Right)or self.anchor:is(f.a.TopRight)or self.anchor:is(f.a.BottomRight))then local R,m=l.getSize()M=R-K end;return M end;function Q:getBaseHeight()local w=self.height;if w~=nil then return w end;w=1+self.padTop+self.padBottom;if self.border>0 then w=w+2 end;return w end;function Q:getHeight(l,L)a.expect(2,L,"number","nil")local w=self:getBaseHeight()if self.fillVertical and not(self.anchor:is(f.a.Bottom)and self.anchor:is(f.a.BottomLeft)and self.anchor:is(f.a.BottomRight))then local m,S=l.getSize()w=S-L+1 end;return w end;function Q:makeScreen(l,I,M,w,N)a.expect(1,l,"table")a.expect(2,I,"table","nil")a.expect(3,M,"number","nil")a.expect(4,w,"number","nil")a.expect(5,N,"boolean","nil")f.h.requireOutput(l)if I==nil then I=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())else I=c.copy(I)end;if N==nil then N=true end;if not f.h.isPos(I)then error("pos must be a ScreenPos")end;if M==nil then M=self:getWidth(l,I.x)end;if w==nil then w=self:getHeight(l,I.y)end;if self.border>0 then M=M-2;w=w-2;I.x=I.x+1;I.y=I.y+1 end;local T=e.FrameScreen(l,self.id,c.copy(I),M,w,self:getTextColor(l),self:getFillColor(l))if N then T:addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)end;local U=fs.open("debug.log","a")U.writeLine(string.format("%s %s %s %s %s",self.id,T.basePos.x,T.basePos.y,T.width,T.height))U.close()return T:ccCompat()end;function Q:render(l)if not self.visible then return end;a.expect(1,l,"table","nil")if l==nil then l=term end;self:validate(l)local p=l.getTextColor()local q=l.getBackgroundColor()local r,s=l.getCursorPos()local I=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())local M=self:getWidth(l,I.x)local w=self:getHeight(l,I.y)local y=self:getBackgroundColor(l)local V=self:getBorderColor(l)local x=self:getTextColor(l)if self.border>0 and(self:getBackgroundColor()~=nil or self:getBorderColor()~=nil)then if self.border==1 then f.h.renderBorder1(l,I,M,w,y,V)elseif self.border==2 then f.h.renderBorder2(l,I,M,w,y,V)else f.h.renderBorder3(l,I,M,w,V)end end;l.setTextColor(x)l.setBackgroundColor(f.h.getColor(self:getFillColor(l),q))local T=self:makeScreen(l,I,M,w,false)if self:getFillColor()~=nil then T.clear()end;f.h.getFrameScreen(T):addPadding(self.padLeft,self.padRight,self.padTop,self.padBottom)Q.super.render(self,T)l.setTextColor(p)l.setBackgroundColor(q)l.setCursorPos(r,s)end;function Q:within(l,O,P)if not self.visible then return false end;a.expect(1,l,"table")f.h.requireOutput(l)a.expect(2,O,"number")a.expect(3,P,"number")a.range(O,1)a.range(P,1)self:validate(l)local W=self.anchor:getPos(l,self:getBaseWidth(),self:getBaseHeight())if f.h.isFrameScreen(l)then l=f.h.getFrameScreen(l)W=e.ScreenPos(l:toAbsolutePos(W.x,W.y))end;local M=self:getWidth(l,W.x)local w=self:getHeight(l,W.y)local X=e.ScreenPos(W.x+M-1,W.y+w-1)return O>=W.x and O<=X.x and P>=W.y and P<=X.y end;function Q:handle(l,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")f.h.requireOutput(l)local T=self:makeScreen(l)for m,h in pairs(self.i)do if h:handle(T,{t,unpack(u)})then return self.bubble end end;if t=="mouse_click"or t=="mouse_up"or t=="monitor_touch"then local I=e.ScreenPos(u[2],u[3])local Y=nil;if self:within(l,I.x,I.y)then local O,P=f.h.getFrameScreen(T):toRealtivePos(I.x,I.y)if t=="mouse_click"then Y=f.e.FrameClickEvent(l,self.id,O,P,u[1])elseif t=="mouse_up"then Y=f.e.FrameDeactivateEvent(l,self.id,O,P,u[1])else Y=f.e.FrameTouchEvent(l,self.id,O,P)end;if Y~=nil then os.queueEvent(Y.name,Y)end;return self.bubble end end;return false end;function Q:bind(l)return J(l,self)end;local Z=J:extend("am.ui.BoundButton")e.BoundButton=Z;function Z:updateLabel(A)self.obj:updateLabel(self.output,A)end;function Z:activate(_)self.obj:activate(self.output,_)end;function Z:deactivate()self.obj:deactivate(self.output)end;function Z:addActivateHandler(a0)return self.obj:addActivateHandler(a0)end;function Z:onActivate(t)self.obj:onActivate(self.output,t)end;function Z:onDeactivate(t)self.obj:onDeactivate(self.output,t)end;function Z:onTouch(t)self.obj:onTouch(self.output,t)end;function Z:onClick(t)self.obj:onClick(self.output,t)end;function Z:onUp(t)self.obj:onUp(self.output,t)end;local a1=Q:extend("am.ui.Button")f.Button=a1;function a1:init(C,A,k)k=k or{}a.expect(1,C,"table")a.expect(2,A,"string")a.field(k,"labelAnchor","table","nil")a.field(k,"disabled","boolean","nil")a.field(k,"activateOnTouch","boolean","nil")a.field(k,"activateOnLeftClick","boolean","nil")a.field(k,"activateOnRightClick","boolean","nil")a.field(k,"activateOnMiddleClick","boolean","nil")if k.labelAnchor==nil then k.labelAnchor=f.a.Middle()end;if k.padLeft==nil then k.padLeft=1 end;if k.disabled==nil then k.disabled=false end;if k.activateOnTouch==nil then k.activateOnTouch=true end;if k.activateOnLeftClick==nil then k.activateOnLeftClick=true end;if k.activateOnRightClick==nil then k.activateOnRightClick=true end;if k.activateOnMiddleClick==nil then k.activateOnMiddleClick=true end;a1.super.init(self,C,k)self.label=B(k.labelAnchor,A,{id=string.format("%s.label",self.id)})self.disabled=k.disabled;self.activated=false;self.activateOnTouch=k.activateOnTouch;self.activateOnLeftClick=k.activateOnLeftClick;self.activateOnRightClick=k.activateOnRightClick;self.activateOnMiddleClick=k.activateOnMiddleClick;self.activateHandlers={}self.touchTimer=nil;self:add(self.label)self:validate()return self end;function a1:updateLabel(l,A)l=self:makeScreen(l)self.label:update(l,A)end;function a1:getBaseWidth()local M=a1.super.getBaseWidth(self)if self.width~=nil then return M end;return M+#self.label.label-1 end;function a1:getFillColor(l)a.expect(1,l,"table","nil")if l~=nil and self.activated then f.h.requireOutput(l)f.h.getColor(self.borderColor,l.getBackgroundColor())end;if self.activated then return self.borderColor end;return self.fillColor end;function a1:getBorderColor(l)a.expect(1,l,"table","nil")if l~=nil and not self.activated then f.h.requireOutput(l)f.h.getColor(self.borderColor,l.getBackgroundColor())end;if self.activated then return self.fillColor end;return self.borderColor end;function a1:activate(l,_)if self.disabled or self.activated then return end;a.expect(2,_,"boolean","nil")self.activated=true;local t=f.e.ButtonActivateEvent(l,self.id,_)os.queueEvent(t.name,t)end;function a1:deactivate(l)if not self.activated then return end;self.activated=false;local t=f.e.ButtonDeactivateEvent(l,self.id)os.queueEvent(t.name,t)end;function a1:addActivateHandler(a0)a.expect(1,a0,"function")local i=tostring(a0)self.activateHandlers[i]=a0;return function()self.activateHandlers[i]=nil end end;function a1:onActivate(l,t)if self.disabled then return end;self.activated=true;for m,a0 in pairs(self.activateHandlers)do a0(self,l,t)end;self:render(l)if t.touch then self.touchTimer=os.startTimer(0.5)end end;function a1:onDeactivate(l,t)self.activated=false;self:render(l)end;function a1:onTouch(l,t)if self.disabled or self.activated or not self.activateOnTouch then return end;self:activate(l,true)end;function a1:onClick(l,t)if self.disabled or self.activated then return end;if t.clickType==f.c.Click.Left and self.activateOnLeftClick then self:activate(l)elseif t.clickType==f.c.Click.Right and self.activateOnRightClick then self:activate(l)elseif t.clickType==f.c.Click.Middle and self.activateOnMiddleClick then self:activate(l)end end;function a1:onUp(l,t)if self.disabled or not self.activated then return end;self:deactivate(l)end;function a1:get(i,l)a.expect(1,i,"string")a.expect(2,l,"table","nil")if i==self.label.id then return self:bind(l)end;if l~=nil then f.h.requireOutput(l)l=self:makeScreen(l)end;return Q.super.get(self,i,l)end;function a1:handle(l,t,...)local t,u=c.cleanEventArgs(t,...)a.expect(1,l,"table")a.expect(2,t,"string")f.h.requireOutput(l)if f.c.l.Events.UI[t]then local a2=u[1]if a2.objId==self.id then if t==f.c.e.Events.frame_touch then self:onTouch(l,a2)elseif t==f.c.e.Events.frame_click then self:onClick(l,a2)elseif t==f.c.e.Events.frame_up then self:onUp(l,a2)elseif t==f.c.e.Events.button_activate then self:onActivate(l,a2)elseif t==f.c.e.Events.button_deactivate then self:onDeactivate(l,a2)end elseif t==f.c.e.Events.text_update then if a2.objId==self.label.id then local D=a2.oldLabel;local E=a2.newLabel;if#E<#D then local q=self.backgroundColor;local a3=self.borderColor;local a4=self.fillColor;self.backgroundColor=l.getBackgroundColor()self.borderColor=l.getBackgroundColor()self.fillColor=l.getBackgroundColor()self.label.label=string.rep(" ",#D)self:render(l)self.backgroundColor=q;self.borderColor=a3;self.fillColor=a4 end;self.label.label=E;self:render(l)return true end end;return self.bubble elseif t=="timer"then if u[1]==self.touchTimer then self.touchTimer=nil;self:deactivate(l)end end;return a1.super.handle(self,l,{t,unpack(u)})end;function a1:bind(l)return Z(l,self)end;return f
