local a=require("cc.expect")require(settings.get("ghu.base").."core/apis/ghu")local b=require("am.core")local c=require("am.ui.bound")local d=require("am.ui.anchor")local e=require("am.ui.const")local f=require("am.ui.event")local g=require("am.ui.helpers")local h=require("am.ui.elements.text")local i,j=require("am.ui.elements.frame")local k=j:extend("am.ui.BoundGroup")c.BoundProgressBar=k;function k:getLabelText()self.obj:getLabelText()end;function k:updateLabel(l,m,n)self.obj:updateLabel(self.output,l,m,n)end;function k:update(o)self.obj:update(self.output,o)end;local p=i:extend("am.ui.ProgressBar")function p:init(q,r)r=r or{}a.expect(1,q,"table")a.field(r,"label","string","nil")a.field(r,"labelAnchor","table","nil")a.field(r,"current","number","nil")a.field(r,"total","number","nil")a.field(r,"displayTotal","number","nil")a.field(r,"progressColor","number","nil")a.field(r,"progressTextColor","number","nil")a.field(r,"progressVertical","boolean","nil")a.field(r,"showProgress","boolean","nil")a.field(r,"showPercent","boolean","nil")if r.label==nil then r.label=""end;if r.labelAnchor==nil then r.labelAnchor=d.Anchor(2,1)end;if r.total==nil then r.total=100 end;if r.current==nil then r.current=0 end;if r.progressColor==nil then r.progressColor=colors.green end;if r.progressTextColor==nil then r.progressTextColor=r.textColor end;if r.showProgress==nil then r.showProgress=true end;if r.showPercent==nil then r.showPercent=true end;if r.progressVertical==nil then r.progressVertical=false end;if r.fillHorizontal==nil then r.fillHorizontal=true end;if r.fillVertical==nil then if r.progressVertical then r.fillVertical=true end end;p.super.init(self,q,r)self.baseLabel=r.label;self.current=r.current;self.displayTotal=r.displayTotal;self.total=r.total;self.progressColor=r.progressColor;self.progressTextColor=r.progressTextColor;self.progressVertical=r.progressVertical;self.showProgress=r.showProgress;self.showPercent=r.showPercent;self.label=h(r.labelAnchor,self:getLabelText(),{id=string.format("%s.label",self.id)})self.fillFrame=i(d.BottomLeft(),{id=string.format("%s.fill",self.id),fillVertical=true,border=0})self.fillLabel=h(d.Anchor(1,1),self:getLabelText(),{id=string.format("%s.fillLabel",self.id)})self:add(self.label)self:validate()return self end;function p:validate(s)p.super.validate(self,s)if self.fillFrame==nil then return end;a.field(self,"baseLabel","string")a.field(self,"current","number")a.range(self.current,0)a.field(self,"total","number")a.range(self.total,math.floor(self.current))a.field(self,"displayTotal","number","nil")a.field(self,"progressColor","number")a.range(self.progressColor,1)a.field(self,"showPercent","boolean")a.field(self,"showProgress","boolean")self.padLeft=0;self.padRight=0;self.padTop=0;self.padBottom=0 end;function p:bind(s)return c.BoundProgressBar(s,self)end;function p:get(t,s)a.expect(1,t,"string")a.expect(2,s,"table","nil")if t==self.label.id or t==self.fillFrame.id or t==self.fillLabel.id then return self:bind(s)end;if s~=nil then g.requireOutput(s)s=self:makeScreen(s)end;return i.super.get(self,t,s)end;function p:getLabelText()local l=self.baseLabel;local o=math.min(self.current,self.total)local u=o/self.total;if self.showPercent then l=l..string.format(" %d%%",u*100)end;if self.showProgress then local v=self.current;local w=self.total;if self.displayTotal~=nil then v=math.floor(u*self.displayTotal)w=self.displayTotal end;l=l..string.format(" [%d/%d]",v,w)end;return l end;function p:render(s)if not self.visible then return end;a.expect(1,s,"table","nil")if s==nil then s=term end;local x=self:makeScreen(s)local y=s.getTextColor()local z=s.getBackgroundColor()local A,B=s.getCursorPos()local l=self:getLabelText()self.label.label=l;self.label.textColor=self:getTextColor(s)p.super.render(self,s)local o=math.min(self.current,self.total)local u=o/self.total;local C,D=x.getSize()local E=self.label.anchor:getPos(x,#l,1)local F;if self.progressVertical then F=math.floor(D*u)else F=math.floor(C*u)end;if F>0 then self.fillLabel.label=l;self.fillLabel.textColor=self.progressTextColor;local G=false;if self.progressVertical then E.y=E.y-(D-F)if E.y>0 then G=true end;self.fillFrame.width=C;self.fillFrame.height=F;self.fillFrame.fillVertical=false;self.fillFrame.fillHorizontal=true else if E.x<=F then G=true end;self.fillFrame.width=F;self.fillFrame.height=D;self.fillFrame.fillVertical=true;self.fillFrame.fillHorizontal=false end;if G then self.fillLabel.anchor.x=E.x;self.fillLabel.anchor.y=E.y;self.fillFrame:add(self.fillLabel)else self.fillFrame:reset()end;self.fillFrame.fillColor=self.progressColor;self.fillFrame:render(x)end;s.setTextColor(y)s.setBackgroundColor(z)s.setCursorPos(A,B)end;function p:updateLabel(s,l,m,n)a.expect(1,s,"table")a.expect(2,l,"string","nil")a.expect(3,m,"boolean","nil")a.expect(4,n,"boolean","nil")g.requireOutput(s)local H=l~=nil and self.baseLabel~=l;local I=m~=nil and self.showProgress~=m;local J=n~=nil and self.showPercent~=n;if not(H or I or J)then return end;local K=f.ProgressBarLabelUpdateEvent(s,self.id)if H then K.oldLabel=self.baseLabel;K.newLabel=l;self.baseLabel=l end;if I then K.oldShowProgress=self.showProgress;K.newShowProgress=m;self.showProgress=m end;if J then K.oldShowPercent=self.showPercent;K.newShowPercent=n;self.showPercent=n end;os.queueEvent(K.name,K)end;function p:update(s,o)a.expect(1,s,"table")a.expect(2,o,"number")g.requireOutput(s)o=math.min(self.total,math.max(0,o))if self.current==o then return end;local K=f.ProgressBarUpdateEvent(s,self.id,self.current,o)self.current=o;os.queueEvent(K.name,K)end;function p:handle(s,K,...)local K,L=b.cleanEventArgs(K,...)a.expect(1,s,"table")a.expect(2,K,"string")g.requireOutput(s)if K==e.e.Events.progress_label_update and L[1].objId==self.id then if L[1].newLabel~=nil then self.baseLabel=L[1].newLabel elseif L[1].newShowProgress~=nil then self.showProgress=L[1].newShowProgress elseif L[1].newShowPercent~=nil then self.showPercent=L[1].newShowPercent end;self:render(s)return true elseif K==e.e.Events.progress_update and L[1].objId==self.id then self.current=math.min(self.total,math.max(0,L[1].newCurrent))self:render(s)return true end;p.super.handle(self,s,{K,unpack(L)})return false end;return p
