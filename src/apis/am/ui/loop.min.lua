local a=require("cc.expect")local b=require("am.core")local c=require("am.ui.base")local d=require("am.ui.const")local e=require("am.ui.event")local f=require("am.ui.helpers")local g=c.UIObject:extend("am.ui.UILoop")function g:init(h)a.expect(1,h,"string","nil")g.super.init(self,h)self.running=false;return self end;function g:cancel()if self.running then self.running=false;local i=e.LoopCancelEvent(self.id)os.queueEvent(i.name,i)end end;function g:run(j,...)local k={j,...}self.running=true;while self.running do local l=os.startTimer(5)local i,m=b.cleanEventArgs(os.pullEvent())local n=nil;if d.l.Events.Terminal[i]then n=term elseif d.l.Events.Monitor[i]then n=peripheral.wrap(m[1])elseif d.l.Events.UI[i]then local o=m[1]if o.outputType=="term"then n=term elseif o.outputType=="monitor"then n=peripheral.wrap(o.outputId)else for p,q in ipairs(k)do if f.isUIScreen(q)then local r=q:get(o.outputId)if r~=nil then n=r:makeScreen()break end end end end end;if i==d.e.Events.loop_cancel and m[1].id==self.id then self.running=false else for p,q in ipairs(k)do if f.isUIScreen(q)then if q:handle({i,table.unpack(m)})then break end elseif n~=nil and q:handle(n,{i,table.unpack(m)})then break end end end;os.cancelTimer(l)end end;return g
